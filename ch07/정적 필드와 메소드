static은 정적이라는 뜻을 갖고 있다. 움직이지 않는다는 뜻 
메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자이다. <-- 이게 무슨 말임?

먼저 같은 이름의 클래스는 두 개 이상 존재할 수 없다. 어떤 필드가 클래스에 소속된다는 것은 곧 그 필드가 프로그램 전체에서 유일하게 존재한다는 것을 의미한다.
따라서 static으로 한정하지 않은 필드는 자동으로 인스턴스에 (new 어쩌고() 로 만든 객체) 소속되며 static으로 한정한 필드는 클래스에 소속된다.
뭔 말이냐 하면 게임에서 마린을 뽑을 때 각자 다른 이름을 가지고 태어난다고 치자 그런데 이게 몇번째 마린인지 알고 싶다면 static을 붙인 필드를 만들어 카운트 하면 된다.
방금 비유를 잼민이 한테 주니깐 예제를 만들어 줬다
~~~~
public class Marine
{
    // 1. 인스턴스 필드 (Non-Static)
    // - new Marine() 할 때마다 마린 '각자'가 가지는 변수
    public string marineName; // 마린의 고유 이름
    public int myMarineID;   // 이 마린의 고유 ID

    // 2. 정적 필드 (Static)
    // - 'Marine' 클래스(설계도/병영) 자체가 단 하나만 가지는 공용 변수
    private static int totalMarineCount = 0;

    // '마린을 뽑을 때' (생성자)
    public Marine(string name)
    {
        // '나(인스턴스)'의 이름을 설정
        this.marineName = name;

        // '공용(Static)' 카운터를 1 증가시킴
        totalMarineCount++;

        // '나(인스턴스)'의 고유 ID를 현재 공용 카운터 값으로 설정
        this.myMarineID = totalMarineCount;

        Console.WriteLine(this.marineName + " 생성 완료! (전체 " + totalMarineCount + "번째 마린)");
    }

    // Static 메소드 (클래스 자체에서 호출)
    public static void ShowTotalCount()
    {
        Console.WriteLine("지금까지 생산된 총 마린 수: " + totalMarineCount);
        // 여기서 marineName 이나 myMarineID 에는 접근할 수 없습니다.
        // 왜? 어떤 '특정' 마린의 이름인지 알 수 없으니까요.
    }
}
class Program
{
    static void Main(string[] args)
    {
        // 마린을 3기 뽑습니다. (인스턴스 3개 생성)
        Marine marine1 = new Marine("레이너");
        Marine marine2 = new Marine("듀크");
        Marine marine3 = new Marine("멩스크");

        // --- 출력 결과 ---
        // 레이너 생성 완료! (전체 1번째 마린)
        // 듀크 생성 완료! (전체 2번째 마린)
        // 멩스크 생성 완료! (전체 3번째 마린)

        // 개별 마린(인스턴스)의 정보 확인
        Console.WriteLine(marine1.marineName + "의 ID: " + marine1.myMarineID); // "레이너의 ID: 1"
        Console.WriteLine(marine2.marineName + "의 ID: " + marine2.myMarineID); // "듀크의 ID: 2"

        // 전체 마린(클래스)의 공용 정보 확인
        // (인스턴스가 없어도 호출 가능)
        Marine.ShowTotalCount(); // "지금까지 생산된 총 마린 수: 3"
    }
}
~~~
아무튼 이런 식으로 프로그램 전체에 걸쳐 공유해야는 변수가 있다면 정적 필드를 이용하자 위 예제를 정적 메소드는 인스턴스 생성 없이 호출이 가능한 메소드다.
그래서 그냥 클래스이름.메소드이름 이런 식으로 호출하셈 

그럼 여기서 정적 메소드가 아닌건 뭐라고 할까? 
그냥 인스턴스 메소드다 인스턴스를 만들면 그 인스턴스에 소속되기 때문 따라서 인스턴스에 생성해야만 호출 가능함 ㅇㅇ

얕은 복사 깊은 복사라는게 있는데 클래스의 인스턴스는 힙에 저장되고 스택에는 그 힙에 있는 객체를 가르키는 참조 변수(주소)가 저장된다.
그래서 위에 예제를 이어서 
Marine marine1 = new Marine("레이너");
Marine marine2 = marine1
이렇게 쓰면 두 객체는 동일한 힙 메모리 주소를 가리키게된다. 둘은 같은 객체가 된거임
그래서 marine2.marineName = "타이커스"; 라고 바꾸면 marine1.marineName을 출력해도 타이커스가 나온다. 이렇게 참조만 살짝 복사한 것을 얕은 복사라고 한다.

그럼 깊은 복사는 뭐냐? 
간단하다 별도의 힙 메모리를 만들어 서로 다른 객체로 저장하는 것이다. 어떻게 하나요?
새로운 객체를 만들고, 그 객체 안의 모든 참조 타입 필드들도 재귀적으로 복사해서 새롭게 만드는 것이다.
아래는 예제 코드 
~~~
using System;

namespace DeepCopy
{
    class MyClass
    {
        public int MyField1;
        public int MyField2;

        public MyClass DeepCopy()
        {
            MyClass newCopy = new MyClass();
            newCopy.MyField1 = this.MyField1;
            newCopy.MyField2 = this.MyField2;

            return newCopy;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            MyClass original = new MyClass(); //원본 객체 생성
            original.MyField1 = 10;
            original.MyField2 = 20;
            MyClass copy = original.DeepCopy(); //서로 다른 객체 생성
            Console.WriteLine($"Original: MyField1 = {original.MyField1}, MyField2 = {original.MyField2}"); //이건 원본 객체
            Console.WriteLine($"Copy: MyField1 = {copy.MyField1}, MyField2 = {copy.MyField2}"); //이건 복사된 객체
        }
    }
}
~~~
